class NMP:
    def __init__(self):
        self.A = []
        self.B = []
        self.C = []
        self.row_a = 0
        self.col_a = 0
        self.row_b = 0
        self.col_b = 0
        self.choice = ''
        self.t_type = ''

    def read_in(self):
        self.A.clear()
        self.B.clear()
        self.C.clear()
        rc = input('Enter size of first matrix: ')
        self.row_a, self.col_a = rc.split()
        self.row_a = int(self.row_a)
        self.col_a = int(self.col_a)
        print('Enter first matrix: ')
        for _i in range(self.row_a):
            x = input()
            x = x.split()
            self.A.append(x)
        if self.choice != '2' and self.choice != '4' and self.choice != '5' and self.choice != '6':
            rc = input('Enter size of second matrix: ')
            self.row_b, self.col_b = rc.split()
            self.row_b = int(self.row_b)
            self.col_b = int(self.col_b)
            print('Enter second matrix: ')
            for _i in range(self.row_b):
                x = input()
                x = x.split()
                self.B.append(x)

    def addition(self):
        for i in range(self.row_a):
            if len(self.A[i][:]) != len(self.B[i][:]):
                self.C = 'ERROR'
                break
            c_in = []
            for j in range(self.col_a):
                c_in.append(str(float(self.A[i][j]) + float(self.B[i][j])))
            self.C.append(c_in)

    def scalar_mult(self, D, s):
        for i in range(len(D)):
            c_in = []
            for j in range(len(D[i][:])):
                c_in.append(str(round(float(D[i][j]) * s, 5)))
            self.C.append(c_in)

    def matrix_mult(self):
        for i in range(self.row_a):
            if len(self.A[i][:]) != len(self.B):
                self.C = 'ERROR'
                break
            c_in = []
            for j in range(self.col_b):
                c_cum = 0
                for k in range(self.col_a):
                    c_cum += float(self.A[i][k]) * float(self.B[k][j])
                c_in.append(str(round(c_cum, 5)))
            self.C.append(c_in)

    def transpose_matrix(self, D):
        E = []
        if self.t_type == '1':
            for i in range(self.row_a):
                c_in = []
                for j in range(self.col_a):
                    c_in.append(D[j][i])
                E.append(c_in)
        if self.t_type == '2':
            for i in range(self.row_a):
                c_in = []
                for j in range(self.col_a):
                    c_in.append(D[self.row_a - j - 1][self.col_a - i - 1])
                E.append(c_in)
        if self.t_type == '3':
            for i in range(self.row_a):
                c_in = []
                for j in range(self.col_a):
                    c_in.append(D[i][self.col_a - j - 1])
                E.append(c_in)
        if self.t_type == '4':
            for i in range(self.row_a):
                c_in = []
                for j in range(self.col_a):
                    c_in.append(D[self.col_a - i - 1][j])
                E.append(c_in)
        return E

    def determinant(self, D):
        deter = 0
        if len(D) != len(D[0][:]):
            self.C = 'ERROR'
            return
        elif len(D) == 1:
            return float(D[0][0])
        elif len(D) == 2:
            return float(D[0][0]) * float(D[1][1]) - float(D[0][1]) * float(D[1][0])
        else:
            for j in range(len(D[0][:])):
                deter += float(D[0][j]) * self.determinant(self.minor(D, 0, j)) * ((-1) ** j)
            return deter

    def cofactor(self, D):
        E = []
        for i in range(len(D)):
            d_in = []
            for j in range(len(D[i][:])):
                d_in.append(self.determinant(self.minor(D, i, j)) * (-1) ** (i + j))
            E.append(d_in)
        return E

    def minor(self, M, k, l):
        nM = []
        for i in range(len(M)):
            if i != k:
                D_in = []
                for j in range(len(M[k][:])):
                    if j != l:
                        D_in.append(M[i][j])
                    else:
                        continue
                nM.append(D_in)
            else:
                continue
        return nM


num = NMP()
while True:
    print('1. Add matrices')
    print('2. Multiply matrix by a constant')
    print('3. Multiply matrices')
    print('4. Transpose matrix')
    print('5. Calculate a determinant')
    print('6. Inverse matrix')
    print('0. Exit')
    num.choice = input('Your choice: ')
    if num.choice == '0':
        break
    if num.choice == '4':
        print('1. Main diagonal')
        print('2. Side diagonal')
        print('3. Vertical line')
        print('4. Horizontal line')
        num.t_type = input('Your choice: ')
    num.read_in()
    if num.choice == '1':
        num.addition()
    if num.choice == '2':
        s = float(input('Enter constant: '))
        num.scalar_mult(num.A, s)
    if num.choice == '3':
        num.matrix_mult()
    if num.choice == '4':
        num.C = num.transpose_matrix(num.A)
    if num.choice == '5':
        deter = num.determinant(num.A)
    if num.choice == '6':
        deter = num.determinant(num.A)
        E = num.cofactor(num.A)
        num.t_type = '1'
        E = num.transpose_matrix(E)
        num.scalar_mult(E, 1 / deter)
    if num.C == 'ERROR':
        print('This operation cannot be performed.')
    elif num.choice == '5':
        print(deter)
    else:
        print('The result is: ')
        for i in range(num.row_a):
            print(' '.join(num.C[i][:]))
